import os
from typing import List, Tuple
import imageio
import torch.utils.data


def img_filter(filename: str) -> bool:
    if filename[-9:] == '_mask.png':
        return False
    else:
        return True


def get_img_paths(path: str) -> List[Tuple[str, str]]:
    r""" A function that traverses the data path of the dataset.
    This function is designed to facilitate loading data to the class `Dataset`.

    Parameters
    ----------
    path: a dataset path that generated by the extract_nii_to_dataset.py, like dataset/val.

    Returns
    -------
    a list of two tuples, the tuples contains img path and mask path in a val, train or test data,
     the tuples likes ('data/val/001/001.png','data/val/001/001_mask.png').


    """
    dirs = []
    img_paths = []
    for d in os.listdir(path):
        dirs.append(os.path.join(path, d))
    for d in dirs:
        file_list = os.listdir(d)
        img_list = sorted(list(filter(img_filter, file_list)))  # return a list, like ['300.png', '301.png', ... ]
        for fn in img_list:  # var fn is filename + extension name, like '300.png'
            img = os.path.join(d, fn)
            mask = os.path.join(d, fn[:-4] + '_mask.png')
            img_paths.append((img, mask))
    return img_paths


class Dataset(torch.utils.data.Dataset):
    def __init__(self, path, transform=None, mask_transform=None, transform_equal=False):
        self.img_paths: List[Tuple[str, str]] = get_img_paths(path)
        self.transform = transform
        self.mask_transform = mask_transform
        self.transform_equal = transform_equal

    def __getitem__(self, index):
        img, mask = self.img_paths[index]
        img = imageio.imread(img)
        mask = imageio.imread(mask)
        if self.transform is None:
            img = torch.from_numpy(img).float() / 255.
        else:
            img = self.transform(img)

        if self.mask_transform is None:
            mask = torch.from_numpy(mask).long()
        else:
            if self.transform_equal:
                mask = self.transform(mask)
            else:
                mask = self.mask_transform(mask)

        img = img.unsqueeze(0)
        mask[mask > 0] = 1

        return img, mask

    def __len__(self):
        return len(self.img_paths)


def data_loader(train_path, val_path, transform=None, mask_transform=None, batch=1, num_workers=0, shuffle=True,
                transform_equal=False):
    dataset_train = Dataset(train_path, transform, mask_transform, transform_equal)
    dataset_val = Dataset(val_path, transform, mask_transform, transform_equal)
    loader_train = torch.utils.data.DataLoader(dataset=dataset_train, batch_size=batch, shuffle=shuffle,
                                               num_workers=num_workers)
    loader_val = torch.utils.data.DataLoader(dataset=dataset_val, batch_size=batch, shuffle=shuffle,
                                             num_workers=num_workers)
    dataloaders = {'train': loader_train, 'val': loader_val}
    return dataloaders
def main():
    train_path = 'D:/nii_test/train'
    val_path = 'D:/nii_test/val'
    data_loader1 = data_loader(train_path, val_path)
    dataloader = data_loader1['train']
    cnt = 0
    for raw, label in dataloader:
        # print(raw)
        # print(label)
        print('raw: ' + str(raw.shape))
        print('label: ' + str(label.shape))
        cnt += 1
        print(cnt)
        if cnt == 1000:
            return
if __name__ == '__main__':
    main()